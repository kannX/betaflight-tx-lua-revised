local a=0;local b=""local c=0;local d=0;local e=false;local f=1;local g;local h=0;local i=1;local j=0;local k={}local l={}local function m(n)local o=1;for p=1,#l do local q=l[p]if not q.hidden then if o<n then o=o+1 else return q end end end end;local function r()c=0;for p=1,#l do local q=m(p)if q and q.type~=11 and q.type~=12 and q.name~=nil then c=p;break end end end;local function s(t)local q=m(c)if q.type==10 then local u=32;if f<=#q.value then u=string.byte(q.value,f)+t end;if u<32 then u=32 elseif u>122 then u=122 end;if f<=#q.value then q.value=string.sub(q.value,1,f-1)..string.char(u)..string.sub(q.value,f+1)else q.value=q.value..string.char(u)end else local v,w=0,0;if q.type<=5 then v=q.min;w=q.max;t=q.step*t elseif q.type==9 then v=0;w=#q.values-1 end;if t<0 and q.value>v or t>0 and q.value<w then q.value=q.value+t end end end;local function x(t)local y=c;local q;repeat y=y+t;if y==0 then y=#l elseif y==1+#l then y=1;d=0 end;q=m(y)until y==c or q and q.type~=11 and q.name;c=y;if c>7+d then d=c-7 elseif c<=d then d=c-1 end end;local function z(A)local B={}local p=1;for C in string.gmatch(A,"([^;]+)")do B[p]=C;p=p+1 end;return B end;local function D(E,F)local G=""while E[F]~=0 do G=G..string.char(E[F])F=F+1 end;F=F+1;return G,F end;local function H(E)local F;a=E[2]b,F=D(E,3)local I=E[F+12]for p=1,I do l[p]={name=nil}end end;local function J(E,F,K)local G=0;for p=0,K-1 do G=bit32.lshift(G,8)+E[F+p]end;return G end;local function L(q,E,F,K)q.value=J(E,F,K)q.min=J(E,F+K,K)q.max=J(E,F+2*K,K)q.default=J(E,F+3*K,K)q.unit,F=D(E,F+4*K)q.step=1 end;local function M(q,K)local N=bit32.lshift(0x80,(K-1)*8)q.value=q.value-bit32.band(q.value,N)*2;q.min=q.min-bit32.band(q.min,N)*2;q.max=q.max-bit32.band(q.max,N)*2;q.default=q.default-bit32.band(q.default,N)*2 end;local function O(q,E,F,K)L(q,E,F,K)M(q,K)end;local function P(Q,R,K)local S={a,0xEA,Q}for p=K-1,0,-1 do S[#S+1]=bit32.rshift(R,8*p)%256 end;crossfireTelemetryPush(0x2D,S)end;local function T(q,K)local R=q.value;P(q.id,R,K)end;local function U(q,K)local R=q.value;if R<0 then R=bit32.lshift(0x100,(K-1)*8)+R end;P(q.id,R,K)end;local function V(q,W,X)lcd.drawNumber(140,W,q.value,LEFT+X)lcd.drawText(lcd.getLastPos(),W,q.unit,X)end;local function Y(q,E,F)L(q,E,F,1)end;local function Z(q)T(q,1)end;local function _(q,E,F)O(q,E,F,1)end;local function a0(q)U(q,1)end;local function a1(q,E,F)L(q,E,F,2)end;local function a2(q)T(q,2)end;local function a3(q,E,F)O(q,E,F,2)end;local function a4(q)U(q,2)end;local function a5(q,E,F)q.value=J(E,F,4)q.min=J(E,F+4,4)q.max=J(E,F+8,4)q.default=J(E,F+12,4)M(q,4)q.prec=E[F+16]if q.prec>2 then q.prec=2 end;q.step=J(E,F+17,4)q.unit,F=D(E,F+21)end;local function a6(q,W,X)local a7;if q.prec==1 then a7=LEFT+X+PREC1 elseif q.prec==2 then a7=LEFT+X+PREC2 else a7=LEFT+X end;lcd.drawNumber(140,W,q.value,a7)lcd.drawText(lcd.getLastPos(),W,q.unit,X)end;local function a8(q)T(q,4)end;local function a9(q,E,F)local aa;aa,F=D(E,F)if aa~=""then q.values=z(aa)end;q.value=E[F]q.min=E[F+1]q.max=E[F+2]q.default=E[F+3]q.unit,F=D(E,F+4)end;local function ab(q)crossfireTelemetryPush(0x2D,{a,0xEA,q.id,q.value})end;local function ac(q,W,X)lcd.drawText(140,W,q.values[q.value+1],X)lcd.drawText(lcd.getLastPos(),W,q.unit,X)end;local function ad(q,E,F)q.value,F=D(E,F)if#E>=F then q.maxlen=E[F]end end;local function ae(q)local S={a,0xEA,q.id}for p=1,string.len(q.value)do S[#S+1]=string.byte(q.value,p)end;S[#S+1]=0;crossfireTelemetryPush(0x2D,S)end;local function af(q,W,X)if e==true and X then lcd.drawText(140,W,q.value,FIXEDWIDTH)lcd.drawText(134+6*f,W,string.sub(q.value,f,f),FIXEDWIDTH+X)else lcd.drawText(140,W,q.value,X)end end;local function ag(q,E,F)q.status=E[F]q.timeout=E[F+1]q.info,F=D(E,F+2)if q.status<2 or q.status>3 then g=nil end end;local function ah(q)if q.status==0 then q.status=1;crossfireTelemetryPush(0x2D,{a,0xEA,q.id,q.status})g=q;h=getTime()+q.timeout end end;local function ai(q,W,X)lcd.drawText(0,W,q.name,X)if q.info~=""then lcd.drawText(140,W,"["..q.info.."]")end end;local aj={{load=Y,save=Z,display=V},{load=_,save=a0,display=V},{load=a1,save=a2,display=V},{load=a3,save=a4,display=V},nil,nil,nil,nil,{load=a5,save=a8,display=a6},{load=a9,save=ab,display=ac},{load=ad,save=ae,display=af},nil,{load=ad,save=ae,display=af},{load=ag,save=ah,display=ai}}local function ak(E)if E[2]~=a or E[3]~=i then k={}j=0;return end;local q=l[i]local al=E[4]for p=5,#E do k[#k+1]=E[p]end;if al>0 then j=j+1 else j=0;q.id=i;q.parent=k[1]q.type=k[2]%128;q.hidden=bit32.rshift(k[2],7)==1;local am,p=D(k,3)if am~=""then local an=""local ao=q.parent;while ao~=0 do an=an.." "ao=l[ao].parent end;q.name=an..am end;if aj[q.type+1]then aj[q.type+1].load(q,k,p)end;if not g then if c==0 and q.hidden~=true and q.type and q.type~=11 and q.type~=12 then r()end;i=1+i%#l end;k={}end end;local function ap()local aq,E=crossfireTelemetryPop()if aq==nil then local ar=getTime()if g then if ar>h then local S={a,0xEA,g.id}crossfireTelemetryPush(0x2D,S)h=ar+g.timeout end elseif ar>h and not e then crossfireTelemetryPush(0x2C,{a,0xEA,i,j})h=ar+200 end elseif aq==0x29 then H(E)elseif aq==0x2B then ak(E)h=0 end end;local function as(at)if at==EVT_EXIT_BREAK then if e==true then e=false;local q=m(c)h=getTime()+200;i,j=q.id,0;k={}aj[q.type+1].save(q)else return"crossfire.lua"end elseif at==EVT_ENTER_BREAK then local q=m(c)if q.name then if q.type==10 then if e==false then e=true;f=1 else f=f+1 end elseif q.type<11 then e=not e end;if e==false then h=getTime()+200;i,j=q.id,0;k={}aj[q.type+1].save(q)end end elseif e then if at==EVT_PLUS_FIRST or at==EVT_PLUS_REPT then s(1)elseif at==EVT_MINUS_FIRST or at==EVT_MINUS_REPT then s(-1)end else if at==EVT_MINUS_FIRST then x(1)elseif at==EVT_PLUS_FIRST then x(-1)end end;lcd.clear()lcd.drawScreenTitle(b,0,0)for W=1,7 do local q=m(d+W)if not q then break elseif q.name==nil then lcd.drawText(0,1+8*W,"...")else local X=c==d+W and(e==true and BLINK or 0)+INVERS or 0;lcd.drawText(0,1+8*W,q.name)if aj[q.type+1]then aj[q.type+1].display(q,1+8*W,X)end end end;return 0 end;local function au(at)local G;if g.status==3 then G=popupConfirmation(g.info,at)else G=popupWarning(g.info,at)end;if G=="OK"then crossfireTelemetryPush(0x2D,{a,0xEA,g.id,4})elseif G=="CANCEL"then crossfireTelemetryPush(0x2D,{a,0xEA,g.id,5})end;return 0 end;local function av()c,e=0,false end;local function aw(at)if at==nil then error("Cannot be run as a model script!")return 2 end;local G;if g~=nil then G=au(at)else G=as(at)end;ap()return G end;return{init=av,run=aw}
